/**
 * Content Generation API
 *
 * Generates content using AI capabilities:
 * - Documents (markdown, text, reports)
 * - Code files
 * - Data exports (JSON, CSV)
 *
 * For images and media, this endpoint can coordinate with
 * external generation services when configured.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getUserContentStorageService } from '@/services/UserContentStorageService';
import { getUserService } from '@/services/UserService';
import logger from '@/utils/logger';

// ============================================================================
// TYPES
// ============================================================================

interface GenerationRequest {
  type: 'document' | 'code' | 'data' | 'report' | 'summary';
  prompt: string;
  conversationId?: string;
  options?: {
    format?: 'markdown' | 'text' | 'json' | 'csv' | 'html';
    style?: 'formal' | 'casual' | 'technical';
    length?: 'short' | 'medium' | 'long';
    title?: string;
  };
}

interface GenerationResult {
  success: boolean;
  content?: {
    id: string;
    name: string;
    type: string;
    url: string;
  };
  preview?: string;
  error?: string;
}

// ============================================================================
// GENERATION TEMPLATES
// ============================================================================

const DOCUMENT_TEMPLATES = {
  report: {
    prefix: '# Report\n\nGenerated on: {{date}}\n\n## Summary\n\n',
    suffix: '\n\n---\n*Generated by Infinity Assistant*',
  },
  summary: {
    prefix: '# Summary\n\n',
    suffix: '\n\n---\n*Generated by Infinity Assistant*',
  },
  document: {
    prefix: '',
    suffix: '\n\n---\n*Created with Infinity Assistant*',
  },
};

// ============================================================================
// GENERATION FUNCTIONS
// ============================================================================

/**
 * Generate a document based on prompt
 * In production, this would call Claude or another LLM
 */
async function generateDocument(
  prompt: string,
  options: GenerationRequest['options']
): Promise<{ content: string; mimeType: string; extension: string }> {
  const format = options?.format || 'markdown';
  const template = DOCUMENT_TEMPLATES[options?.style as keyof typeof DOCUMENT_TEMPLATES] || DOCUMENT_TEMPLATES.document;

  // Generate content structure based on prompt
  // This is a placeholder - in production, call an LLM
  const generatedContent = `
## ${options?.title || 'Generated Document'}

${prompt}

### Content

This document was generated based on your request. The full generation capabilities
would integrate with Claude API for intelligent content creation.

### Details

- Request: ${prompt}
- Format: ${format}
- Style: ${options?.style || 'default'}
- Generated: ${new Date().toISOString()}
`.trim();

  const content = template.prefix.replace('{{date}}', new Date().toLocaleDateString()) +
                  generatedContent +
                  template.suffix;

  const mimeTypes: Record<string, string> = {
    markdown: 'text/markdown',
    text: 'text/plain',
    json: 'application/json',
    csv: 'text/csv',
    html: 'text/html',
  };

  const extensions: Record<string, string> = {
    markdown: 'md',
    text: 'txt',
    json: 'json',
    csv: 'csv',
    html: 'html',
  };

  return {
    content,
    mimeType: mimeTypes[format] || 'text/plain',
    extension: extensions[format] || 'txt',
  };
}

/**
 * Generate code based on prompt
 */
async function generateCode(
  prompt: string,
  options: GenerationRequest['options']
): Promise<{ content: string; mimeType: string; extension: string }> {
  // Placeholder for code generation
  const code = `/**
 * Generated Code
 *
 * Request: ${prompt}
 * Generated: ${new Date().toISOString()}
 */

// This is a placeholder for the generated code.
// Full implementation would integrate with Claude API.

export function generatedFunction() {
  // TODO: Implement based on prompt
  console.log('Generated by Infinity Assistant');
}
`;

  return {
    content: code,
    mimeType: 'text/typescript',
    extension: 'ts',
  };
}

/**
 * Generate data export
 */
async function generateData(
  prompt: string,
  options: GenerationRequest['options']
): Promise<{ content: string; mimeType: string; extension: string }> {
  const format = options?.format || 'json';

  if (format === 'csv') {
    const csv = `id,name,description,created_at
1,Generated Item,${prompt},${new Date().toISOString()}
`;
    return { content: csv, mimeType: 'text/csv', extension: 'csv' };
  }

  const data = {
    generated: true,
    prompt,
    timestamp: new Date().toISOString(),
    data: {
      message: 'This is generated data based on your request',
      request: prompt,
    },
  };

  return {
    content: JSON.stringify(data, null, 2),
    mimeType: 'application/json',
    extension: 'json',
  };
}

// ============================================================================
// API HANDLER
// ============================================================================

/**
 * POST /api/content/generate
 *
 * Generate content using AI
 */
export async function POST(request: NextRequest) {
  try {
    const body: GenerationRequest = await request.json();
    const { type, prompt, conversationId, options } = body;

    if (!type || !prompt) {
      return NextResponse.json(
        { error: 'type and prompt are required' },
        { status: 400 }
      );
    }

    // Get user ID
    const userService = getUserService();
    const userId = userService.getAnonymousUserId(
      request.cookies.get('infinity_anon_user')?.value
    );

    logger.info('[Content Generate] Starting generation', {
      userId,
      type,
      promptLength: prompt.length,
    });

    // Generate content based on type
    let generated: { content: string; mimeType: string; extension: string };

    switch (type) {
      case 'document':
      case 'report':
      case 'summary':
        generated = await generateDocument(prompt, options);
        break;
      case 'code':
        generated = await generateCode(prompt, options);
        break;
      case 'data':
        generated = await generateData(prompt, options);
        break;
      default:
        return NextResponse.json(
          { error: `Unsupported generation type: ${type}` },
          { status: 400 }
        );
    }

    // Generate filename
    const timestamp = Date.now();
    const title = options?.title || type;
    const sanitizedTitle = title.replace(/[^a-zA-Z0-9]/g, '_').slice(0, 50);
    const filename = `${sanitizedTitle}_${timestamp}.${generated.extension}`;

    // Store the generated content
    const storageService = getUserContentStorageService();
    const result = await storageService.storeGeneratedContent(
      userId,
      generated.content,
      {
        name: filename,
        mimeType: generated.mimeType,
        conversationId,
        prompt: prompt.slice(0, 500), // Store truncated prompt
        tags: ['generated', type],
      }
    );

    if (!result.success) {
      return NextResponse.json(
        { error: result.error || 'Failed to store generated content' },
        { status: 500 }
      );
    }

    logger.info('[Content Generate] Content generated and stored', {
      userId,
      contentId: result.content?.id,
      type,
    });

    // Return result with preview
    const response: GenerationResult = {
      success: true,
      content: {
        id: result.content!.id,
        name: filename,
        type: generated.mimeType,
        url: result.signedUrl || '',
      },
      preview: generated.content.slice(0, 500), // First 500 chars as preview
    };

    return NextResponse.json(response);
  } catch (error) {
    logger.error('[Content Generate] Error:', error);
    return NextResponse.json(
      { error: 'Content generation failed' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/content/generate
 *
 * Get available generation types and options
 */
export async function GET() {
  return NextResponse.json({
    types: [
      {
        id: 'document',
        name: 'Document',
        description: 'Generate markdown or text documents',
        formats: ['markdown', 'text', 'html'],
        icon: 'üìÑ',
      },
      {
        id: 'report',
        name: 'Report',
        description: 'Generate structured reports',
        formats: ['markdown', 'html'],
        icon: 'üìä',
      },
      {
        id: 'summary',
        name: 'Summary',
        description: 'Generate summaries of content',
        formats: ['markdown', 'text'],
        icon: 'üìù',
      },
      {
        id: 'code',
        name: 'Code',
        description: 'Generate code snippets and files',
        formats: ['typescript', 'javascript', 'python'],
        icon: 'üíª',
      },
      {
        id: 'data',
        name: 'Data Export',
        description: 'Generate structured data exports',
        formats: ['json', 'csv'],
        icon: 'üìä',
      },
    ],
    options: {
      formats: ['markdown', 'text', 'json', 'csv', 'html'],
      styles: ['formal', 'casual', 'technical'],
      lengths: ['short', 'medium', 'long'],
    },
  });
}
